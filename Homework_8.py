import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats


# Округление элементов массива
def np_round(arr, val):
    return np.array([list(map(lambda ell: round(ell, val), el)) for el in arr])


"""
Домашнее задание к Уроку-8
"""

"""
Задание-1:
1) Даны значения величины заработной платы заемщиков банка (zp) 
и значения их поведенческого кредитного скоринга (ks):
zp = [35, 45, 190, 200, 40, 70, 54, 150, 120, 110],
ks = [401, 574, 874, 919, 459, 739, 653, 902, 746, 832].
Найдите ковариацию этих двух величин с помощью элементарных действий, а затем с помощью функции cov из numpy
Полученные значения должны быть равны.
Найдите коэффициент корреляции Пирсона с помощью ковариации и среднеквадратичных отклонений двух признаков, 
а затем с использованием функций из библиотек numpy и pandas.
"""

# Пояснение:
# Для вычисления прямым вычислением воспользуемся зависимостью:
# cov_xy = M(XY) - M(X) * M(Y)

# Исходные данные:
zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])

# Расчет:
# 1. Ковариация
cov_m = np.mean(zp * ks) - np.mean(zp) * np.mean(ks)       # Прямой расчет
cov_np = np.cov(zp, ks, ddof=0)                             # Смешенная ковариация

# 2. Коэффициент корреляции Пирсона
#   - используем выражение: r = ov_xy / (σ_x * σ_y)
sigma_zp = np.std(zp, ddof=0)
sigma_ks = np.std(ks, ddof=0)
corr_m = cov_m / (sigma_zp * sigma_ks)
#   - используем функции из библиотек numpy и pandas
corr_np = np.corrcoef(zp, ks)


# вывод результатов проверки
print()
print('Задание-1.')
print('--------------------------------')
print(f'Заданы значения признаков: '
      f'\n- Зарплата = {zp} '
      f'\n- Поведенческий кредитный скоринг = {ks}')
print(f'Ковариация рассчитанная через средние = {round(cov_m, 2)}')
print(f'Ковариация рассчитанная встроенными средствами numpy:'
      f'\n{np_round(cov_np, 2)}')
print(f'Коэффициент корреляции Пирсона:'
      f'\n- расчет с помощью ковариации и среднеквадратичных отклонений двух признаков = {round(corr_m, 3)}'
      f'\n- расчет с использованием функций из библиотек numpy =\n'
      f'{np_round(corr_np, 3)}')


"""
Задание-2:
Измерены значения IQ выборки студентов,
обучающихся в местных технических вузах:
131, 125, 115, 122, 131, 115, 107, 99, 125, 111.
Известно, что в генеральной совокупности IQ распределен нормально.
Найдите доверительный интервал для математического ожидания с надежностью 0.95.
"""

# Исходные данные:
iq = np.array([131, 125, 115, 122, 131, 115, 107, 99, 125, 111])
alfa = 1 - 0.95
n = iq.size

# Расчет:
# По условию задания отсутствуют данные генеральной совокупности.
# В связи с этим используем формулу доверительного интервала через t-критерий Стьюдента:
# 𝑥̅ ± t_(𝛼/2) * 𝜎/√𝑛, если 𝜎 генеральной совокупности не известна
M = 0 + np.mean(iq)                       # средняя по выборке iq
d = np.var(iq, ddof=1)                    # дисперсия по выборке iq
t_alfa = stats.t.ppf(1-alfa/2, (n-1))     # квантиль для двухстороннего интервала

# Истинное значение величины IQ находится в доверительном интервале
z_delta = t_alfa * np.sqrt(d/n)

confidence_l = round(M - z_delta, 2)
confidence_r = round(M + z_delta, 2)

# вывод результатов проверки
print()
print('Задание-2.')
print('--------------------------------')
print(f'Истинное значение величины IQ = {iq}, со средним значением M = {round(M, 3)}\n'
      f'с доверительной вероятностью = {1-alfa} '
      f'находится в интервале [{confidence_l} ... {confidence_r}]')


"""
Задание-3:
Известно, что рост футболистов в сборной распределен нормально с дисперсией генеральной совокупности, 
равной 25 кв.см. Объем выборки равен 27, среднее выборочное составляет 174.2. 
Найдите доверительный интервал для математического ожидания с надежностью 0.95.
"""

# Пояснения:
# Доверительный интервал для среднего арифметического
# X ± z_(α/2) * σ/√n при известной σ генеральной совокупности

# Исходные данные:
M_sample = 174.2
alfa = 1 - 0.95
S_sample = 25
N_sample = 27

# Расчет:
z_alfa = stats.t.ppf(1-alfa/2, (N_sample-1))
z_delta = z_alfa * S_sample / np.sqrt(N_sample)

confidence_l = round(M_sample - z_delta, 2)
confidence_r = round(M_sample + z_delta, 2)

# Вывод результатов проверки
print()
print('Задание-3.')
print('--------------------------------')
print(f'Доверительный интервал мат. ожидания = {M_sample}\n'
      f'с надежностью = {1-alfa} '
      f'составляет [{confidence_l} ... {confidence_r}]')


exit()


# Вывод результатов расчета корреляции Пирсона
def show_result(X, Y, C, lim=0.5, number=None):
    tit = f'Эксперимент {number}:'
    print(tit)
    print(f'Выборка X = {X}')
    print(f'Выборка Y = {Y}')
    print(f'Коэффициент корреляции Пирсона:\n{C}')
    print()

    plt.scatter(X, Y)
    plt.title(tit)
    plt.xlabel('Выборка X')
    plt.ylabel('Выборка Y')
    plt.show()


# Задание-1 Семинара
x = np.array([10,8, 13, 9,11,14, 6,4,12, 7,5])
y1 = np.array([8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68 ])

# x= np.array([ 10,8, 13, 9,11,14, 6,4,12, 7,5 ])
y2 = np.array([ 9.14, 8.14, 8.74,8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74])

# x= np.array([ 10,8, 13, 9,11,14, 6,4,12, 7,5 ])
y3 = np.array([7.46,6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73])

x4 = np.array([8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8])
y4 = np.array([6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25,12.5, 5.56, 7.91, 6.89])

x0= np.array([ 10, 8, 13, 9, 11, 14, 6, 4, 12, 7,5, 15, 16, 18 ])
y0 = np.array([ 9.14, 8.14, 8.74,8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74, 6.5, 5, 2.9])

# Расчет коэффициентов корреляции:
c_kf1 = np.corrcoef(x, y1)
c_kf2 = np.corrcoef(x, y2)
c_kf3 = np.corrcoef(x, y3)
c_kf4 = np.corrcoef(x4, y4)
c_kf0 = np.corrcoef(x0, y0)

print('Решение Задания-1')
print('-------------------')
show_result(x, y1, c_kf1, 1)
show_result(x, y2, c_kf2, 2)
show_result(x, y3, c_kf3, 3)
show_result(x4, y4, c_kf4, 4)
show_result(x0, y0, c_kf0, 5)


"""
Задача 2
Провести двусторонний тест и ответить на вопрос, есть ли статистически значимые
различия между средними 2х нормально распределенных генеральных совокупностей,
представленных следующими независимыми выборками:
a = np.array([12, 10, 11, 19, 13, 11, 17, 15, 19, 14, 21, 18, 21, 11, 17, 14, 15, 17, 20, 19])
b = np.array([11, 13, 18, 15, 17, 18, 10, 21, 26, 15, 11, 12, 15, 17, 10, 18, 18, 12,21, 20])
Уровень статистической значимости принять за 5%
1 . Используйте функцию в Python:
2. Имея p-value из функции рассчитать наблюдаемое значение критерия.
3. Оценить возможную корреляцию между указанными выборками, отразить графически
"""

alfa = 5/100      # 5%
a = np.array([12, 10, 11, 19, 13, 11, 17, 15, 19, 14, 21, 18, 21, 11, 17, 14, 15, 17, 20, 19])
b = np.array([11, 13, 18, 15, 17, 18, 10, 21, 26, 15, 11, 12, 15, 17, 10, 18, 18, 12,21, 20])

# Проверка выборок на нормальность
print(stats.shapiro(a))
print(stats.shapiro(b))

stat, p_value = stats.ttest_ind(a, b)

txt_G0 = 'Нет статистически значимых различий'
txt_G1 = 'Есть статистически значимые различия'

print('Решение Задания-2')
print('-------------------')
print(f'Между генеральными совокупностями: \n {a} и\n {b}')
print(f'{txt_G0 if p_value > alfa else txt_G1} (alfa, p_value = {alfa, p_value})')

show_result(a, b, np.corrcoef(a, b), number='Задание-2')
